HTTP server written in C++\hypertarget{md_README_autotoc_md1}{}\doxysection{Introduction}\label{md_README_autotoc_md1}
\href{https://cdn.intra.42.fr/pdf/pdf/66921/en.subject.pdf}{\texttt{ Project Page}}

The Hypertext Transfer Protocol (HTTP) is an application protocol for distributed, collaborative, hypermedia information systems.

HTTP is the foundation of data communication for the World Wide Web, where hypertext documents include hyperlinks to other resources that the user can easily access. For example, by a mouse click or by tapping the screen in a web browser.

HTTP was developed to facilitate hypertext and the World Wide Web.

The primary function of a web server is to store, process, and deliver web pages to clients. The communication between client and server takes place using the Hypertext Transfer Protocol (HTTP).

Pages delivered are most frequently HTML documents, which may include images, style sheets, and scripts in addition to the text content.

Multiple web servers may be used for a high-\/traffic website.

A user agent, commonly a web browser or web crawler, initiates communication by requesting a specific resource using HTTP and the server responds with the content of that resource or an error message if unable to do so. The resource is typically a real file on the server’s secondary storage, but this is not necessarily the case and depends on how the webserver is implemented.

While the primary function is to serve content, full implementation of HTTP also includes ways of receiving content from clients. This feature is used for submitting web forms, including the uploading of files.\hypertarget{md_README_autotoc_md2}{}\doxysection{Mandatory}\label{md_README_autotoc_md2}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ }\\\cline{1-2}
\endhead
Program Name   &webserv    \\\cline{1-2}
Turn in files   &Makefile, $\ast$.\{h, hpp\}, $\ast$.cpp, $\ast$.tpp, $\ast$.ipp, configuration files    \\\cline{1-2}
Makefile   &NAME, all, clean, fclean, re    \\\cline{1-2}
Arguments   &\mbox{[}a configuration file\mbox{]}    \\\cline{1-2}
External func.   &Everything in C++ 98. execve, dup, dup2, pipe, strerror, errno, dup, dup2, fork, htons, htonl, ntohs, ntohl, select, poll, epoll (epoll\+\_\+create, epoll\+\_\+ctl, epoll\+\_\+wait), kqueue (kqueue, kevent), socket, accept, listen, send, recv, bind, connect, inet\+\_\+addr, setsockopt, getsockname, getprotobyname, fcntl    \\\cline{1-2}
libft   &no    \\\cline{1-2}
Description   &A HTTP server in C++ 98   \\\cline{1-2}
\end{longtabu}


You must write a HTTP server in C++ 98.

Your executable will be run as follows\+: {\ttfamily ./webserv \mbox{[}configuration file\mbox{]}}

\begin{quote}
Even if poll() is mentionned in the subject and the evaluation scale, you can use any equivalent such as select(), kqueue(), or epoll(). \end{quote}
\begin{quote}
Please read the RFC and do some tests with telnet and NGINX before starting this project. Even if you don’t have to implement all the RFC, reading it will help you develop the required features. \end{quote}
\hypertarget{md_README_autotoc_md3}{}\doxysection{Requirements}\label{md_README_autotoc_md3}

\begin{DoxyItemize}
\item Your program has to take a configuration file as argument, or use a default path.
\item You can’t execve another web server.
\item Your server must never block and the client can be bounced properly if necessary.
\item It must be non-\/blocking and use only 1 {\ttfamily poll()} (or equivalent) for all the I/O operations between the client and the server (listen included).
\item {\ttfamily poll()} (or equivalent) must check read and write at the same time.
\item You must never do a read or a write operation without going through {\ttfamily poll()} (or equivalent).
\item Checking the value of errno is strictly forbidden after a read or a write operation.
\item You don’t need to use {\ttfamily poll()} (or equivalent) before reading your configuration file. $>$Because you have to use non-\/blocking file descriptors, it is possible to use read/recv or write/send functions with no poll() (or equivalent), and your server wouldn’t be blocking. But it would consume more system resources. Thus, if you try to read/recv or write/send in any file descriptor without using poll() (or equivalent), your grade will be 0.
\item You can use every macro and define like {\ttfamily FD\+\_\+\+SET}, {\ttfamily FD\+\_\+\+CLR}, {\ttfamily FD\+\_\+\+ISSET}, {\ttfamily FD\+\_\+\+ZERO} (understanding what and how they do it is very useful).
\item A request to your server should never hang forever.
\item Your server must be compatible with the web browser of your choice.
\item We will consider that NGINX is HTTP 1.\+1 compliant and may be used to compare headers and answer behaviors.
\item Your HTTP response status codes must be accurate.
\item You server must have default error pages if none are provided.
\item You can’t use fork for something else than CGI (like PHP, or Python, and so forth).
\item You must be able to serve a fully static website.
\item Clients must be able to upload files.
\item You need at least GET, POST, and DELETE methods.
\item Stress tests your server. It must stay available at all cost.
\item Your server must be able to listen to multiple ports (see Configuration file).
\end{DoxyItemize}\hypertarget{md_README_autotoc_md4}{}\doxysection{Mac\+OS}\label{md_README_autotoc_md4}
\begin{quote}
Since Mac\+OS doesn’t implement {\ttfamily write()} the same way as other Unix OSes, you are allowed to use {\ttfamily fcntl()}. You must use file descriptors in non-\/blocking mode in order to get a behavior similar to the one of other Unix OSes. \end{quote}
\begin{quote}
However, you are allowed to use {\ttfamily fcntl()} only as follows\+: {\ttfamily fcntl(fd, F\+\_\+\+SETFL, O\+\_\+\+NONBLOCK);} Any other flag is forbidden. \end{quote}
\hypertarget{md_README_autotoc_md5}{}\doxysection{Configuration File}\label{md_README_autotoc_md5}
\begin{quote}
You can get some inspiration from the ’server’ part of NGINX configuration file. \end{quote}
In the configuration file, you should be able to\+: Choose the port and host of each ’server’.
\begin{DoxyItemize}
\item Setup the server\+\_\+names or not.
\item The first server for a host\+:port will be the default for this host\+:port (that means it will answer to all the requests that don’t belong to an other server).
\item Setup default error pages.
\item Limit client body size.
\item Setup routes with one or multiple of the following rules/configuration (routes wont be using regexp)\+:
\begin{DoxyItemize}
\item Define a list of accepted HTTP methods for the route.
\item Define a HTTP redirection.
\item Define a directory or a file from where the file should be searched (for example, if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet).
\item Turn on or off directory listing.
\item Set a default file to answer if the request is a directory.
\item Execute CGI based on certain file extension (for example .php).
\item Make the route able to accept uploaded files and configure where they should be saved.
\begin{DoxyItemize}
\item Do you wonder what a CGI is?
\item Because you won’t call the CGI directly, use the full path as PATH\+\_\+\+INFO.
\item Just remember that, for chunked request, your server needs to unchunked it and the CGI will expect EOF as end of the body.
\item Same things for the output of the CGI. If no content\+\_\+length is returned from the CGI, EOF will mark the end of the returned data.
\item Your program should call the CGI with the file requested as first argument.
\item The CGI should be run in the correct directory for relative path file access.
\item Your server should work with one CGI (php-\/\+CGI, Python, and so forth).
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

You must provide some configuration files and default basic files to test and demonstrate every feature works during evaluation.

\begin{quote}
If you’ve got a question about one behavior, you should compare your program behavior with NGINX’s. For example, check how does server\+\_\+name work. We’ve shared with you a small tester. It’s not mandatory to pass it if everything works fine with your browser and tests, but it can help you hunt some bugs. \end{quote}
\begin{quote}
The important thing is resilience. Your server should never die. \end{quote}
\begin{quote}
Do not test with only one program. Write your tests with a more convenient language such as Python or Golang, and so forth. Even in C or C++ if you want to. \end{quote}
